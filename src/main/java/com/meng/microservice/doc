微服务架构的痛点
一.一致性：强一致性和弱一致性
二.高性能：容量评估和性能测试
三.高可用：4个9或者5个9 99.99%
四.可扩展：可修改性、迭代新功能、可插拔
五.可伸缩：应用层和资源层随着硬件的增加先行增加
六.安全性：防偷窥、防泄漏、防抵赖、防篡改、防中间人攻击

保证分布式服务一致性的最佳实战
ACID ->  CAP -> BASE
一.一致性原理
ACID
  1.原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生
  2.一致性（Consistency）  事务前后数据的完整性必须保持一致。
  3.隔离性（Isolation）
    事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
  4.持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的
CAP
  1.一致性（Consistency） 数据一致更新，所有的数据更新都是同步的
  2.可用性（Availability）好的响应性能、完全的可用性指的是在任何故障模型下，服务都会在有限的时间内处理响应
  3.分区容错性（Partition tolerance）可靠性
  在保证分区容错性的情况下，一致性和可用性互斥
  分布式事务强一致性能低
BASE
  1.BA Basically Avaliable 基本可用
  2.Soft State 软状态，状态可以有一段时间不同步
  3.Eventually Consistent 最终一致，最终数据是一致的就可以，而不是时时都保持一致
二.一致性协议
  1.两阶段提交协议   堵塞式协议一旦出问题得人工干预处理
  2.三阶段提交协议   非堵塞式协议，解决部分两阶段部分问题，添加资源检查，但一旦出问题得人工干预处理
  3.TCC try commit cancel log,两阶段和三阶段提交的变种，若cancel处异常则需要补偿机制处理或人工干预
三.最终一致性
  1.查询模式  服务根据操作id去查询当前状态，去核对数据的当前状态
  2.补偿模式  更具查询的状态去继续执行操作或者回滚操作或取消
  3.异步确保模式 主流程中的非核心业务异步处理，保证主流程性能和数据正确，异步处理非核心业务
  4.定期核对模式 第三方核对系统定期处理其他系统异常数据
  5.可靠的消息模式1  解耦、非主流程拆分等、侵入业务数据库
  6.可靠性消息模式2  独立数据库，以消息和接口api与其它服务进行通信
四.服务交互模式
  1.同步调用  同步调用，阻塞等待处理结果
  2.异步受理  异步返回处理结果通过接口返回或者消息
  3.消息队列
五.同步与异步选择
  1.业务允许的情况下可以异步的尽量使用异步，异步操作会增加额外的处理逻辑
  2.从技术角度看耗时时间短的同步操作效率更好
六.超时模式
  1.同步两状态（成功、失败）网络接口超时  查询然后再做处理
  2.同步两状态（成功、失败）网络内部调用其他服务超时 内部查询然后取消或者回滚操作
  3.同步三状态（成功、处理中、失败）接口超时 查询然后等待或重试或取消或者回滚操作，软状态
  4.同步三状态（成功、处理中、失败）内部超时 内部查询然后等待或重试或取消或者回滚操作，软状态
  5.异步受理接口超时  查询然后再做处理
  6.异步受理内部超时  内部查询然后等待或重试或取消或者回滚操作，软状态
  7.异步受理回调超时  查询回调然后再做处理
  8.消息队列发送超时  可靠的消息模式1 或 可靠的消息模式2
  9.消息队列接收超时  幂等  消息的确认模式（自动确认或 人工确定）  或  先人工确认但不做业务处理将消息存到本地数据库然后一步执行业务操作
  一直不成功的需人工干预
七.补偿的博弈
  1.服务1调用服务2，如果服务2响应服务1，并且告诉服务1消息我接收了，那么服务1的任务就完成了，在这种情况下，服务2通常会先持久
  消息然后告诉服务1接收成功了，随后服务2才开始处业务，避免服务进程被杀掉消息丢失的情况
  2..服务1调用服务2，如果服务2没有给出明确的接收响应，那么服务1应该持续尝试测试，直至服务2明确回复已经接收消息，这种情况下
  消息容易出现重复，因此在服务2中通常要保证滤重或者幂等性
八.缓存使用的一致性模式
  1.缓存是用来加速的，牺牲了一致性获得高性能，只适用于特殊场景
  2.操持数据库和缓存的强一致性是个伪命题
  3.如果性能要求不是非常高，尽量使用分布式缓存而不是本地缓存
  4.存缓存的时候一定存完全，如果缓存数据一部分有效，一部分无效，宁可放弃缓存
  5.通常情况下读的顺序要先缓存后数据库，写的顺序要先数据库再缓存
九.迁移开发的设计模式